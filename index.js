// Emperor Group Manager Bot ‚Äì "Imperial Edition" üëë
// Telegraf v4 (Node.js 18+)
// ==============================================
// (c) Fixed for MySQL + ESM + Telegraf v4 webhook
// ==============================================

import 'dotenv/config'
import express from 'express'
import { Telegraf, Markup } from 'telegraf'
import { message } from 'telegraf/filters'
import mysql from 'mysql2/promise'

// ---------- ENV ----------
const BOT_TOKEN = process.env.BOT_TOKEN
if (!BOT_TOKEN) throw new Error('BOT_TOKEN missing in .env')

const FORCE_JOIN = process.env.FORCE_JOIN || '' // e.g. @its4_Four (empty to disable)
const CAPTCHA_TIMEOUT_SEC = +(process.env.CAPTCHA_TIMEOUT_SEC || 120)
const WEBHOOK_URL = process.env.WEBHOOK_URL
const PORT = process.env.PORT || 3000

// ---------- BOT & DB ----------
console.log('Bot starting...')
console.log('BOT_TOKEN:', !!BOT_TOKEN)

const bot = new Telegraf(BOT_TOKEN)

// ÿß⁄Øÿ± DATABASE_URL ÿØÿßÿ±€å (ŸÖÿ´ŸÑÿßŸã mysql://user:pass@host:port/dbname)
// €åÿß ÿßÿ≤ ⁄Øÿ≤€åŸÜŸá‚ÄåŸáÿß€å ÿ¨ÿØÿß⁄ØÿßŸÜŸá ÿßÿ≥ÿ™ŸÅÿßÿØŸá ⁄©ŸÜ
const pool = await mysql.createPool({
  uri: process.env.DATABASE_URL, // ÿß⁄Øÿ± ŸÜÿØÿßÿ±€åÿå ⁄©ÿßŸÖŸÜÿ™ ⁄©ŸÜ Ÿà ÿ®ŸÇ€åŸá‚Äå€å ŸÅ€åŸÑÿØŸáÿß ÿ±Ÿà Ÿæÿ± ⁄©ŸÜ
  // host: process.env.DB_HOST,
  // user: process.env.DB_USER,
  // password: process.env.DB_PASS,
  // database: process.env.DB_NAME,
  waitForConnections: true,
  connectionLimit: 10,
  queueLimit: 0
})

// ---------- DB MIGRATIONS ----------
async function migrate() {
  await pool.query(`
    CREATE TABLE IF NOT EXISTS chat_groups (
      chat_id BIGINT PRIMARY KEY,
      title VARCHAR(255),
      emperor_id BIGINT,
      rules TEXT,
      welcome_enabled TINYINT DEFAULT 1,
      antispam_enabled TINYINT DEFAULT 1,
      captcha_enabled TINYINT DEFAULT 1,
      force_join_enabled TINYINT DEFAULT 0,
      force_join_channel VARCHAR(255) DEFAULT '',
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
    );
  `)
  await pool.query(`
    CREATE TABLE IF NOT EXISTS roles (
      chat_id BIGINT,
      user_id BIGINT,
      role VARCHAR(50),
      PRIMARY KEY (chat_id, user_id)
    );
  `)
  await pool.query(`
    CREATE TABLE IF NOT EXISTS warns (
      chat_id BIGINT,
      user_id BIGINT,
      count INT DEFAULT 0,
      last_reason TEXT,
      PRIMARY KEY (chat_id, user_id)
    );
  `)
  await pool.query(`
    CREATE TABLE IF NOT EXISTS mutes (
      chat_id BIGINT,
      user_id BIGINT,
      until_ts BIGINT,
      PRIMARY KEY (chat_id, user_id)
    );
  `)
  await pool.query(`
    CREATE TABLE IF NOT EXISTS audit (
      id INT AUTO_INCREMENT PRIMARY KEY,
      chat_id BIGINT,
      actor_id BIGINT,
      action VARCHAR(50),
      target_id BIGINT,
      reason TEXT,
      ts TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );
  `)
  await pool.query(`
    CREATE TABLE IF NOT EXISTS referrals (
      ref_user_id BIGINT,
      new_user_id BIGINT,
      ts TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );
  `)
}
await migrate()

// ---------- STATEMENTS ----------
async function upsertGroup({ chat_id, title, emperor_id, force_join_enabled, force_join_channel }) {
  await pool.query(
    `
    INSERT INTO chat_groups (chat_id, title, emperor_id, force_join_enabled, force_join_channel)
    VALUES (?, ?, ?, ?, ?)
    ON DUPLICATE KEY UPDATE title=VALUES(title), updated_at=CURRENT_TIMESTAMP
  `,
    [chat_id, title, emperor_id, force_join_enabled, force_join_channel]
  )
}

async function setEmperor(chat_id, emperor_id) {
  await pool.query(
    `UPDATE chat_groups SET emperor_id=?, updated_at=CURRENT_TIMESTAMP WHERE chat_id=?`,
    [emperor_id, chat_id]
  )
}

async function getGroup(chat_id) {
  const [rows] = await pool.query(`SELECT * FROM chat_groups WHERE chat_id=?`, [chat_id])
  return rows[0]
}

async function setCfg({ chat_id, rules, welcome_enabled, antispam_enabled, captcha_enabled, force_join_enabled, force_join_channel }) {
  await pool.query(
    `
    UPDATE chat_groups SET 
      rules=?, welcome_enabled=?, antispam_enabled=?, captcha_enabled=?, force_join_enabled=?, force_join_channel=?, updated_at=CURRENT_TIMESTAMP
    WHERE chat_id=?
  `,
    [rules, welcome_enabled, antispam_enabled, captcha_enabled, force_join_enabled, force_join_channel, chat_id]
  )
}

async function getRole(chat_id, user_id) {
  const [rows] = await pool.query(`SELECT role FROM roles WHERE chat_id=? AND user_id=?`, [chat_id, user_id])
  return rows[0]?.role
}

async function setRole(chat_id, user_id, role) {
  await pool.query(
    `
    INSERT INTO roles(chat_id,user_id,role) VALUES (?,?,?)
    ON DUPLICATE KEY UPDATE role=VALUES(role)
  `,
    [chat_id, user_id, role]
  )
}

async function delRole(chat_id, user_id) {
  await pool.query(`DELETE FROM roles WHERE chat_id=? AND user_id=?`, [chat_id, user_id])
}

async function getWarnCount(chat_id, user_id) {
  const [rows] = await pool.query(`SELECT count FROM warns WHERE chat_id=? AND user_id=?`, [chat_id, user_id])
  return rows[0]?.count || 0
}

async function setWarnCount(chat_id, user_id, count, last_reason) {
  await pool.query(
    `
    INSERT INTO warns(chat_id,user_id,count,last_reason) VALUES (?,?,?,?)
    ON DUPLICATE KEY UPDATE count=VALUES(count), last_reason=VALUES(last_reason)
  `,
    [chat_id, user_id, count, last_reason]
  )
}

async function resetWarn(chat_id, user_id) {
  await pool.query(`DELETE FROM warns WHERE chat_id=? AND user_id=?`, [chat_id, user_id])
}

async function setMute(chat_id, user_id, until_ts) {
  await pool.query(
    `
    INSERT INTO mutes(chat_id,user_id,until_ts) VALUES (?,?,?)
    ON DUPLICATE KEY UPDATE until_ts=VALUES(until_ts)
  `,
    [chat_id, user_id, until_ts]
  )
}

async function delMute(chat_id, user_id) {
  await pool.query(`DELETE FROM mutes WHERE chat_id=? AND user_id=?`, [chat_id, user_id])
}

async function logAudit(chat_id, actor_id, action, target_id, reason) {
  await pool.query(
    `INSERT INTO audit(chat_id,actor_id,action,target_id,reason) VALUES (?,?,?,?,?)`,
    [chat_id, actor_id, action, target_id, reason]
  )
}

// ---------- ROLES & PERMISSIONS ----------
const Roles = {
  EMPEROR: 'emperor',
  QUEEN: 'queen',
  CONSUL: 'consul',
  KNIGHT: 'knight',
  PRINCE: 'prince',
  PRINCESS: 'princess',
  DUKE: 'duke',
  BARON: 'baron',
  CITIZEN: 'citizen'
}

const RoleLabelsFA = {
  emperor: 'üëë ÿßŸÖŸæÿ±ÿßÿ™Ÿàÿ±', queen: 'üë∏ ŸÖŸÑ⁄©Ÿá', consul: 'üëÆ ⁄©ŸÜÿ≥ŸàŸÑ',
  knight: '‚öîÔ∏è ÿ¥ŸàÿßŸÑ€åŸá', prince: 'ü§¥ ÿ¥ÿßŸáÿ≤ÿßÿØŸá', princess: 'üë∏ Ÿæÿ±ŸÜÿ≥ÿ≥',
  duke: 'üéñ ÿØŸà⁄©', baron: 'üèµ ÿ®ÿßÿ±ŸàŸÜ', citizen: 'üë• ÿ¥Ÿáÿ±ŸàŸÜÿØ'
}
const RoleLabelsEN = {
  emperor: 'Emperor', queen: 'Queen', consul: 'Consul',
  knight: 'Knight', prince: 'Prince', princess: 'Princess',
  duke: 'Duke', baron: 'Baron', citizen: 'Citizen'
}

const HIERARCHY = [Roles.CITIZEN, Roles.BARON, Roles.DUKE, Roles.PRINCESS, Roles.PRINCE, Roles.KNIGHT, Roles.CONSUL, Roles.QUEEN, Roles.EMPEROR]
function roleRank(role) { return Math.max(0, HIERARCHY.indexOf(role || Roles.CITIZEN)) }

async function getActorRole(ctx, userId) {
  const g = await getGroup(ctx.chat.id)
  if (g?.emperor_id === userId) return Roles.EMPEROR

  const stored = await getRole(ctx.chat.id, userId)
  if (stored === Roles.QUEEN) return Roles.QUEEN

  try {
    const m = await ctx.getChatMember(userId)
    if (['creator', 'administrator'].includes(m.status)) return Roles.CONSUL
  } catch {}
  return stored || Roles.CITIZEN
}

function canAct(actorRole, targetRole, allowEqual = false) {
  if (!targetRole) targetRole = Roles.CITIZEN
  if (actorRole === Roles.EMPEROR || actorRole === Roles.QUEEN) return true
  const a = roleRank(actorRole)
  const b = roleRank(targetRole)
  return allowEqual ? a >= b : a > b
}

// ---------- KEYWORDS (FA/EN) ----------
const KW = {
  ban: [/\bban\b/i, /ÿ™ÿ®ÿπ€åÿØ/i],
  unban: [/\bunban\b/i, /ÿ¢ÿ≤ÿßÿØ(?:\s|)ÿ≥ÿßÿ≤€å|ÿ±ŸÅÿπ\s?ÿ®ŸÜ|ÿ±ŸÅÿπ\s?ÿ™ÿ®ÿπ€åÿØ/i],
  mute: [/\bmute\b/i, /ÿ≥⁄©Ÿàÿ™|ŸÖ€åŸàÿ™/i],
  unmute: [/\bunmute\b/i, /ÿ±ŸÅÿπ\s?ÿ≥⁄©Ÿàÿ™|ÿ¢ÿ≤ÿßÿØ\s?ÿßÿ≤\s?ÿ≥⁄©Ÿàÿ™/i],
  warn: [/\bwarn\b/i, /ÿßÿÆÿ∑ÿßÿ±/i],
  unwarn: [/\bunwarn\b/i, /ÿ≠ÿ∞ŸÅ\s?ÿßÿÆÿ∑ÿßÿ±|ÿ±€åÿ≥ÿ™\s?ÿßÿÆÿ∑ÿßÿ±/i],
  purge: [/\bpurge\b/i, /Ÿæÿß⁄©ÿ≥ÿßÿ≤€å|Ÿæÿß⁄©\s?⁄©ÿ±ÿØŸÜ/i],
  panel: [/\bpanel\b/i, /ŸæŸÜŸÑ/i],
  rules: [/\brules\b/i, /ŸÇŸàÿßŸÜ€åŸÜ/i],
  setrules: [/\bset\s?rules\b/i, /ÿ™ŸÜÿ∏€åŸÖ\s?ŸÇŸàÿßŸÜ€åŸÜ/i],
  promote: [/\bpromote\b/i, /ÿßÿ±ÿ™ŸÇÿß|ÿ™ŸÜÿ∏€åŸÖ/i],
  demote: [/\bdemote\b/i, /ÿ™ŸÜÿ≤ŸÑ|⁄©ÿßŸáÿ¥\s?ÿ±ÿ™ÿ®Ÿá/i]
}

const ROLE_KW = {
  [Roles.QUEEN]: [/\bqueen\b/i, /ŸÖŸÑ⁄©Ÿá/i],
  [Roles.KNIGHT]: [/\bknight\b/i, /ÿ¥ŸàÿßŸÑ€åŸá/i],
  [Roles.PRINCE]: [/\bprince\b/i, /ÿ¥ÿßŸáÿ≤ÿßÿØŸá/i],
  [Roles.PRINCESS]: [/\bprince(?:ss)?\b/i, /Ÿæÿ±ŸÜÿ≥ÿ≥/i],
  [Roles.DUKE]: [/\bduke\b/i, /ÿØŸà⁄©/i],
  [Roles.BARON]: [/\bbaron\b/i, /ÿ®ÿßÿ±ŸàŸÜ/i],
  [Roles.CITIZEN]: [/\bcitizen\b/i, /ÿ¥Ÿáÿ±ŸàŸÜÿØ/i]
}

function matchAny(text, regexArr) { return regexArr.some(r => r.test(text)) }

// ---------- HELPERS ----------
async function detectEmperor(ctx) {
  const admins = await ctx.getChatAdministrators()
  const creator = admins.find(a => a.status === 'creator')
  if (creator) await setEmperor(ctx.chat.id, creator.user.id)
  return creator?.user
}

function parseDuration(str) {
  if (!str) return null
  if (!/^\d+[smhd]$/i.test(str)) return null
  const n = parseInt(str)
  const u = str.slice(-1).toLowerCase()
  const mul = u === 's' ? 1e3 : u === 'm' ? 60e3 : u === 'h' ? 3600e3 : 86400e3
  return n * mul
}

async function safeRestrict(ctx, userId, perms, untilDateSec) {
  try {
    await ctx.restrictChatMember(userId, { permissions: perms, until_date: untilDateSec })
  } catch (e) {
    try { await ctx.reply('‚ö†Ô∏è ' + (e.description || e.message)) } catch {}
  }
}

async function safeBan(ctx, userId) {
  try { await ctx.banChatMember(userId) } catch (e) {
    try { await ctx.reply('‚ö†Ô∏è ' + (e.description || e.message)) } catch {}
  }
}
async function safeUnban(ctx, userId) { try { await ctx.unbanChatMember(userId) } catch {} }

function human(ms) {
  const s = Math.floor(ms / 1000)
  if (s < 60) return `${s}s`
  const m = Math.floor(s / 60), r = s % 60
  if (m < 60) return `${m}m${r ? `${r}s` : ''}`
  const h = Math.floor(m / 60), mr = m % 60
  if (h < 24) return `${h}h${mr ? `${mr}m` : ''}`
  const d = Math.floor(h / 24), hr = h % 24
  return `${d}d${hr ? `${hr}h` : ''}`
}

function extractArgs(text) {
  const parts = text.trim().split(/\s+/)
  const dur = parts.find(p => /^\d+[smhd]$/i.test(p))
  const reason = text.replace(/\s*\d+[smhd]\s*/i, '').trim()
  return { dur, reason }
}

// ---------- STATE ----------
const spamMap = new Map() // key: chat:user => { last, count, ts }

// ---------- START ----------
bot.start(async (ctx) => {
  if (ctx.chat.type !== 'private') return
  const ref = ctx.startPayload?.match(/^ref_(\d+)$/)?.[1]
  if (ref) {
    try { await pool.query(`INSERT INTO referrals(ref_user_id,new_user_id) VALUES (?,?)`, [+ref, ctx.from.id]) } catch {}
  }
  return ctx.reply(
    'ÿ≥ŸÑÿßŸÖ! ŸÖŸÜ ¬´ÿßŸÖŸæÿ±ÿßÿ™Ÿàÿ± ⁄Øÿ±ŸàŸá¬ª Ÿáÿ≥ÿ™ŸÖ üëë\nAdd me to a group and promote to admin.\n‚Äî Actions in groups are keyword-based (no / commands).\n‚Äî Reply to a user and say: "ban" / "ÿ™ÿ®ÿπ€åÿØ", "mute 10m" / "ÿ≥⁄©Ÿàÿ™ €±€∞m", etc.',
    Markup.inlineKeyboard([[Markup.button.url('‚ûï Add to Group', 'https://t.me/' + ctx.me + '?startgroup=true')]])
  )
})

// ---------- CHAT MEMBER UPDATES ----------
bot.on('my_chat_member', async (ctx) => {
  const status = ctx.myChatMember.new_chat_member.status
  if (['administrator', 'member'].includes(status)) {
    await upsertGroup({
      chat_id: ctx.chat.id,
      title: ctx.chat.title || '',
      emperor_id: null,
      force_join_enabled: FORCE_JOIN ? 1 : 0,
      force_join_channel: FORCE_JOIN
    })
    const emp = await detectEmperor(ctx)
    await ctx.reply(`ÿßŸÖŸæÿ±ÿßÿ™Ÿàÿ±€å ŸÅÿπÿßŸÑ ÿ¥ÿØ.${emp ? ' üëë ' + (emp.first_name) : ''}\n‚Äî ÿØÿ≥ÿ™Ÿàÿ±ÿßÿ™: ÿ±€åŸæŸÑÿß€å ⁄©ŸÜ Ÿà ÿ®⁄ØŸà ¬´ÿ™ÿ®ÿπ€åÿØ/ban¬ª, ¬´ÿ≥⁄©Ÿàÿ™/mute 10m¬ª, ¬´ÿßÿÆÿ∑ÿßÿ±/warn¬ª, ¬´ÿßÿ±ÿ™ŸÇÿß ÿ¥ŸàÿßŸÑ€åŸá/promote knight¬ª Ÿà...`)
  }
})

// ---------- ANTI-SPAM, CAPTCHA, FORCE-JOIN ----------
bot.on(message('new_chat_members'), async (ctx) => {
  const g = await getGroup(ctx.chat.id)
  if (!g) return
  for (const m of ctx.message.new_chat_members) {
    if (g.welcome_enabled) await ctx.reply(`üèõ ÿÆŸàÿ¥ ÿ¢ŸÖÿØ€å ${m.first_name}!`)
    if (g.force_join_enabled && g.force_join_channel) {
      try { await ctx.restrictChatMember(m.id, { permissions: { can_send_messages: false } }) } catch {}
      await ctx.replyWithMarkdown(
        `ÿ®ÿ±ÿß€å ÿØÿ≥ÿ™ÿ±ÿ≥€åÿå ÿπÿ∂Ÿà ${g.force_join_channel} ÿ¥Ÿà Ÿà ÿ≥Ÿæÿ≥ ÿ±Ÿà€å *ÿ™ÿ£€å€åÿØ ÿπÿ∂Ÿà€åÿ™* ÿ®ÿ≤ŸÜ.`,
        Markup.inlineKeyboard([[Markup.button.callback('‚úÖ ÿ™ÿ£€å€åÿØ ÿπÿ∂Ÿà€åÿ™', 'fj:' + m.id)]])
      )
    } else if (g.captcha_enabled) {
      try { await ctx.restrictChatMember(m.id, { permissions: { can_send_messages: false } }) } catch {}
      await ctx.reply(
        `ÿ®ÿ±ÿß€å ÿßÿ´ÿ®ÿßÿ™ ÿßŸÜÿ≥ÿßŸÜ ÿ®ŸàÿØŸÜ ÿ∏ÿ±ŸÅ ${CAPTCHA_TIMEOUT_SEC}s ÿ±Ÿà€å ÿØ⁄©ŸÖŸá ÿ®ÿ≤ŸÜ.`,
        Markup.inlineKeyboard([[Markup.button.callback('ŸÖŸÜ ÿ±ÿ®ÿßÿ™ ŸÜ€åÿ≥ÿ™ŸÖ ü§ñ‚ùå', 'cap:' + m.id)]])
      )
      setTimeout(async () => {
        try {
          const member = await ctx.getChatMember(m.id)
          if (member && ['restricted'].includes(member.status)) await safeBan(ctx, m.id)
        } catch {}
      }, CAPTCHA_TIMEOUT_SEC * 1000)
    }
  }
})

bot.action(/fj:(\d+)/, async (ctx) => {
  await ctx.answerCbQuery()
  const uid = +ctx.match[1]
  if (ctx.from.id !== uid) return ctx.reply('ŸÅŸÇÿ∑ ŸáŸÖÿßŸÜ ⁄©ÿßÿ±ÿ®ÿ± ŸÖ€å‚Äåÿ™ŸàÿßŸÜÿØ ÿ™ÿ£€å€åÿØ ⁄©ŸÜÿØ.')
  const g = await getGroup(ctx.chat.id)
  if (!g?.force_join_channel) return
  try {
    const member = await ctx.telegram.getChatMember(g.force_join_channel, uid)
    if (['member', 'administrator', 'creator'].includes(member.status)) {
      await safeRestrict(ctx, uid, {
        can_send_messages: true,
        can_send_audios: true,
        can_send_documents: true,
        can_send_photos: true,
        can_send_videos: true,
        can_send_video_notes: true,
        can_send_voice_notes: true,
        can_send_polls: true,
        can_add_web_page_previews: true,
        can_send_other_messages: true
      }, 0)
      await ctx.reply('‚úÖ ÿ™ÿ£€å€åÿØ ÿ¥ÿØ. ÿÆŸàÿ¥ ÿ¢ŸÖÿØ€å!')
    } else {
      await ctx.reply('ŸáŸÜŸàÿ≤ ÿπÿ∂Ÿà ⁄©ÿßŸÜÿßŸÑ ŸÜ€åÿ≥ÿ™€å.')
    }
  } catch {
    await ctx.reply('ÿßÿ®ÿ™ÿØÿß Ÿàÿßÿ±ÿØ ⁄©ÿßŸÜÿßŸÑ ÿ¥Ÿàÿå ÿ®ÿπÿØ ÿØŸàÿ®ÿßÿ±Ÿá ÿßŸÖÿ™ÿ≠ÿßŸÜ ⁄©ŸÜ.')
  }
})

bot.action(/cap:(\d+)/, async (ctx) => {
  await ctx.answerCbQuery('Verified')
  const uid = +ctx.match[1]
  if (ctx.from.id !== uid) return ctx.reply('ÿß€åŸÜ ÿØ⁄©ŸÖŸá ŸÖÿÆÿµŸàÿµ ÿ¥ÿÆÿµ ÿØ€å⁄Øÿ±€å ÿßÿ≥ÿ™.')
  await safeRestrict(ctx, uid, {
    can_send_messages: true,
    can_send_audios: true,
    can_send_documents: true,
    can_send_photos: true,
    can_send_videos: true,
    can_send_video_notes: true,
    can_send_voice_notes: true,
    can_send_polls: true,
    can_add_web_page_previews: true,
    can_send_other_messages: true
  }, 0)
  await ctx.reply('‚úÖ ÿÆŸàÿ¥ ÿ¢ŸÖÿØ€å!')
})

// ---------- TEXT HANDLER ----------
bot.on(message('text'), async (ctx) => {
  const g = await getGroup(ctx.chat.id)
  if (!g) return

  // Anti-spam: repeat & links
  if (g.antispam_enabled) {
    const key = `${ctx.chat.id}:${ctx.from.id}`
    const mem = spamMap.get(key) || { last: '', count: 0, ts: 0 }
    const now = Date.now()
    if (ctx.message.text === mem.last && now - mem.ts < 6000) mem.count++
    else { mem.count = 1; mem.last = ctx.message.text }
    mem.ts = now; spamMap.set(key, mem)
    if (mem.count >= 4) {
      const until = Math.floor((Date.now() + 2 * 60 * 1000) / 1000)
      await safeRestrict(ctx, ctx.from.id, { can_send_messages: false }, until)
      await setMute(ctx.chat.id, ctx.from.id, until)
      await logAudit(ctx.chat.id, ctx.from.id, 'auto-mute', ctx.from.id, 'flood')
      await ctx.reply('üîá ÿ®Ÿá‚ÄåÿÆÿßÿ∑ÿ± ÿßÿ≥ŸæŸÖ €≤ ÿØŸÇ€åŸÇŸá ÿ≥⁄©Ÿàÿ™ ÿ¥ÿØ.')
      return
    }
    if (/(https?:\/\/|t\.me\/|telegram\.me\/)/i.test(ctx.message.text)) {
      try { await ctx.deleteMessage() } catch {}
      const c = await getWarnCount(ctx.chat.id, ctx.from.id)
      const next = c + 1
      await setWarnCount(ctx.chat.id, ctx.from.id, next, 'link')
      if (next >= 3) {
        await safeBan(ctx, ctx.from.id)
        await resetWarn(ctx.chat.id, ctx.from.id)
        await ctx.reply('üö´ ÿ™ÿ®ÿπ€åÿØ ÿ®Ÿá‚ÄåÿÆÿßÿ∑ÿ± ŸÑ€åŸÜ⁄©/ÿßÿ≥ŸæŸÖ.')
      } else {
        await ctx.reply(`‚ö†Ô∏è ÿßÿ±ÿ≥ÿßŸÑ ŸÑ€åŸÜ⁄© ŸÖŸÖŸÜŸàÿπ. ÿßÿÆÿ∑ÿßÿ± ${next}/3`)
      }
      return
    }
  }

  const text = ctx.message.text.trim()
  const replyTo = ctx.message.reply_to_message
  const actorId = ctx.from.id
  const actorRole = await getActorRole(ctx, actorId)

  // Inline panel
  if (matchAny(text, KW.panel)) {
    const isBoss = [Roles.EMPEROR, Roles.QUEEN, Roles.CONSUL].includes(actorRole)
    if (!isBoss) return
    const g2 = await getGroup(ctx.chat.id)
    return ctx.reply('üõ° ŸæŸÜŸÑ ŸÖÿØ€åÿ±€åÿ™ ÿßŸÖŸæÿ±ÿßÿ™Ÿàÿ±€å', Markup.inlineKeyboard([
      [Markup.button.callback(g2.antispam_enabled ? 'ÿ∂ÿØÿßÿ≥ŸæŸÖ: ÿ±Ÿàÿ¥ŸÜ ‚úÖ' : 'ÿ∂ÿØÿßÿ≥ŸæŸÖ: ÿÆÿßŸÖŸàÿ¥ ‚ùå', 'cfg:antispam')],
      [Markup.button.callback(g2.welcome_enabled ? 'ÿÆŸàÿ¥ÿßŸÖÿØ: ÿ±Ÿàÿ¥ŸÜ ‚úÖ' : 'ÿÆŸàÿ¥ÿßŸÖÿØ: ÿÆÿßŸÖŸàÿ¥ ‚ùå', 'cfg:welcome')],
      [Markup.button.callback(g2.captcha_enabled ? '⁄©Ÿæ⁄Üÿß: ÿ±Ÿàÿ¥ŸÜ ‚úÖ' : '⁄©Ÿæ⁄Üÿß: ÿÆÿßŸÖŸàÿ¥ ‚ùå', 'cfg:captcha')],
      [Markup.button.callback(g2.force_join_enabled ? 'ÿßÿ¨ÿ®ÿßÿ± ÿπÿ∂Ÿà€åÿ™: ÿ±Ÿàÿ¥ŸÜ ‚úÖ' : 'ÿßÿ¨ÿ®ÿßÿ± ÿπÿ∂Ÿà€åÿ™: ÿÆÿßŸÖŸàÿ¥ ‚ùå', 'cfg:fj')]
    ]))
  }

  // Rules show/set
  if (matchAny(text, KW.rules)) {
    if (!g.rules) return ctx.reply('üìú ŸÇÿßŸÜŸàŸÜ€å ÿ´ÿ®ÿ™ ŸÜÿ¥ÿØŸá.')
    return ctx.reply('üìú ŸÇŸàÿßŸÜ€åŸÜ:\n' + g.rules)
  }
  if (matchAny(text, KW.setrules)) {
    if (![Roles.EMPEROR, Roles.QUEEN, Roles.CONSUL].includes(actorRole)) return
    const rulesText = text.replace(/^(set\s?rules|ÿ™ŸÜÿ∏€åŸÖ\s?ŸÇŸàÿßŸÜ€åŸÜ)/i, '').trim()
    await setCfg({
      chat_id: ctx.chat.id,
      rules: rulesText,
      welcome_enabled: g.welcome_enabled,
      antispam_enabled: g.antispam_enabled,
      captcha_enabled: g.captcha_enabled,
      force_join_enabled: g.force_join_enabled,
      force_join_channel: g.force_join_channel
    })
    return ctx.reply('üìú ŸÇŸàÿßŸÜ€åŸÜ ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ÿ¥ÿØ.')
  }

  // Moderation actions require a replied target
  if (!replyTo) return
  const target = replyTo.from
  const targetRole = await getActorRole(ctx, target.id)

  // PROMOTE / DEMOTE
  if (matchAny(text, KW.promote)) {
    if (![Roles.EMPEROR, Roles.QUEEN].includes(actorRole)) return ctx.reply('ŸÅŸÇÿ∑ ÿßŸÖŸæÿ±ÿßÿ™Ÿàÿ±/ŸÖŸÑ⁄©Ÿá.')
    const role = Object.keys(ROLE_KW).find(r => matchAny(text, ROLE_KW[r]))
    if (!role) return ctx.reply('ŸÜŸÇÿ¥ Ÿæ€åÿØÿß ŸÜÿ¥ÿØ. ŸÖÿ´ÿßŸÑ: "promote knight" / "ÿ™ŸÜÿ∏€åŸÖ ÿ¥ŸàÿßŸÑ€åŸá"')
    if (!canAct(actorRole, targetRole, true)) return ctx.reply('ÿßÿ¨ÿßÿ≤Ÿá ŸÜÿØÿßÿ±€å ÿ±Ÿà€å ÿ±ÿ™ÿ®ŸáŸî ÿ®ÿ±ÿßÿ®ÿ±/ÿ®ÿßŸÑÿßÿ™ÿ± ÿßÿπŸÖÿßŸÑ ⁄©ŸÜ€å.')
    await setRole(ctx.chat.id, target.id, role)
    return ctx.reply(`‚úÖ ÿßÿ±ÿ™ŸÇÿß: ${target.first_name} ‚Üí ${RoleLabelsFA[role]} (${RoleLabelsEN[role]})`)
  }

  if (matchAny(text, KW.demote)) {
    if (![Roles.EMPEROR, Roles.QUEEN].includes(actorRole)) return
    if (!canAct(actorRole, targetRole, false)) return ctx.reply('ÿßÿ¨ÿßÿ≤Ÿá ŸÜÿØÿßÿ±€å.')
    await delRole(ctx.chat.id, target.id)
    return ctx.reply(`‚úÖ ÿ™ŸÜÿ≤ŸÑ: ${target.first_name} ‚Üí ${RoleLabelsFA[Roles.CITIZEN]}`)
  }

  // BAN / UNBAN
  if (matchAny(text, KW.ban)) {
    if (!canAct(actorRole, targetRole)) return ctx.reply('ÿßÿ¨ÿßÿ≤ŸáŸî ÿ™ÿ®ÿπ€åÿØ ÿß€åŸÜ ⁄©ÿßÿ±ÿ®ÿ± ÿ±ÿß ŸÜÿØÿßÿ±€å.')
    await safeBan(ctx, target.id)
    await logAudit(ctx.chat.id, actorId, 'ban', target.id, '-')
    return ctx.reply(`üö´ ÿ™ÿ®ÿπ€åÿØ ÿ¥ÿØ: ${target.first_name}`)
  }
  if (matchAny(text, KW.unban)) {
    if (![Roles.EMPEROR, Roles.QUEEN, Roles.CONSUL].includes(actorRole)) return
    await safeUnban(ctx, target.id)
    await logAudit(ctx.chat.id, actorId, 'unban', target.id, '-')
    return ctx.reply(`‚úÖ ÿ±ŸÅÿπ ÿ™ÿ®ÿπ€åÿØ: ${target.first_name}`)
  }

  // MUTE / UNMUTE
  if (matchAny(text, KW.mute)) {
    if (!canAct(actorRole, targetRole)) return ctx.reply('ÿßÿ¨ÿßÿ≤Ÿá ŸÜÿØÿßÿ±€å.')
    const { dur } = extractArgs(text)
    const ms = dur ? parseDuration(dur) : 10 * 60 * 1000
    const until = Math.floor((Date.now() + ms) / 1000)
    await safeRestrict(ctx, target.id, { can_send_messages: false }, until)
    await setMute(ctx.chat.id, target.id, until)
    await logAudit(ctx.chat.id, actorId, 'mute', target.id, '-')
    return ctx.reply(`üîá ÿ≥⁄©Ÿàÿ™ ${target.first_name} ÿ™ÿß ${human(ms)}`)
  }
  if (matchAny(text, KW.unmute)) {
    if (![Roles.EMPEROR, Roles.QUEEN, Roles.CONSUL].includes(actorRole)) return
    await safeRestrict(ctx, target.id, {
      can_send_messages: true,
      can_send_audios: true,
      can_send_documents: true,
      can_send_photos: true,
      can_send_videos: true,
      can_send_video_notes: true,
      can_send_voice_notes: true,
      can_send_polls: true,
      can_add_web_page_previews: true,
      can_send_other_messages: true
    }, 0)
    await delMute(ctx.chat.id, target.id)
    await logAudit(ctx.chat.id, actorId, 'unmute', target.id, '-')
    return ctx.reply(`üîä ÿ±ŸÅÿπ ÿ≥⁄©Ÿàÿ™: ${target.first_name}`)
  }

  // WARN / UNWARN
  if (matchAny(text, KW.warn)) {
    if (!canAct(actorRole, targetRole)) return ctx.reply('ÿßÿ¨ÿßÿ≤Ÿá ŸÜÿØÿßÿ±€å.')
    const c = await getWarnCount(ctx.chat.id, target.id)
    const next = c + 1
    await setWarnCount(ctx.chat.id, target.id, next, '-')
    await logAudit(ctx.chat.id, actorId, 'warn', target.id, '-')
    if (next >= 3) {
      await safeBan(ctx, target.id)
      await resetWarn(ctx.chat.id, target.id)
      return ctx.reply('üö´ €≥ ÿßÿÆÿ∑ÿßÿ± ‚Üí ÿ™ÿ®ÿπ€åÿØ ÿ¥ÿØ.')
    }
    return ctx.reply(`‚ö†Ô∏è ÿßÿÆÿ∑ÿßÿ± ${next}/3 ÿ®ÿ±ÿß€å ${target.first_name}`)
  }
  if (matchAny(text, KW.unwarn)) {
    if (![Roles.EMPEROR, Roles.QUEEN, Roles.CONSUL].includes(actorRole)) return
    await resetWarn(ctx.chat.id, target.id)
    await logAudit(ctx.chat.id, actorId, 'unwarn', target.id, '-')
    return ctx.reply('‚úÖ ÿßÿÆÿ∑ÿßÿ±Ÿáÿß ÿ±€åÿ≥ÿ™ ÿ¥ÿØ.')
  }

  // PURGE
  if (matchAny(text, KW.purge)) {
    if (![Roles.EMPEROR, Roles.QUEEN, Roles.CONSUL].includes(actorRole)) return
    try {
      const fromId = replyTo.message_id
      const toId = ctx.message.message_id
      for (let mid = fromId; mid <= toId; mid++) {
        // Ÿáÿ± Ÿæ€åÿßŸÖ ŸÖŸÖ⁄©ŸÜŸá Ÿæÿß⁄© ŸÜÿ¥Ÿáÿõ ÿßÿØÿßŸÖŸá ÿ®ÿØŸá
        // eslint-disable-next-line no-await-in-loop
        await ctx.deleteMessage(mid).catch(() => {})
      }
      await logAudit(ctx.chat.id, actorId, 'purge', 0, '-')
    } catch (e) { await ctx.reply('Ÿæÿß⁄©ÿ≥ÿßÿ≤€å ŸÜÿßŸÖŸàŸÅŸÇ.') }
  }
})

// ---------- INLINE CONFIG TOGGLES ----------
bot.action('cfg:antispam', async (ctx) => {
  await ctx.answerCbQuery()
  const g = await getGroup(ctx.chat.id)
  const val = g.antispam_enabled ? 0 : 1
  await setCfg({ chat_id: ctx.chat.id, rules: g.rules, welcome_enabled: g.welcome_enabled, antispam_enabled: val, captcha_enabled: g.captcha_enabled, force_join_enabled: g.force_join_enabled, force_join_channel: g.force_join_channel })
  await ctx.editMessageText(val ? 'ÿ∂ÿØÿßÿ≥ŸæŸÖ: ÿ±Ÿàÿ¥ŸÜ ‚úÖ' : 'ÿ∂ÿØÿßÿ≥ŸæŸÖ: ÿÆÿßŸÖŸàÿ¥ ‚ùå')
})

bot.action('cfg:welcome', async (ctx) => {
  await ctx.answerCbQuery()
  const g = await getGroup(ctx.chat.id)
  const val = g.welcome_enabled ? 0 : 1
  await setCfg({ chat_id: ctx.chat.id, rules: g.rules, welcome_enabled: val, antispam_enabled: g.antispam_enabled, captcha_enabled: g.captcha_enabled, force_join_enabled: g.force_join_enabled, force_join_channel: g.force_join_channel })
  await ctx.editMessageText(val ? 'ÿÆŸàÿ¥ÿßŸÖÿØ: ÿ±Ÿàÿ¥ŸÜ ‚úÖ' : 'ÿÆŸàÿ¥ÿßŸÖÿØ: ÿÆÿßŸÖŸàÿ¥ ‚ùå')
})

bot.action('cfg:captcha', async (ctx) => {
  await ctx.answerCbQuery()
  const g = await getGroup(ctx.chat.id)
  const val = g.captcha_enabled ? 0 : 1
  await setCfg({ chat_id: ctx.chat.id, rules: g.rules, welcome_enabled: g.welcome_enabled, antispam_enabled: g.antispam_enabled, captcha_enabled: val, force_join_enabled: g.force_join_enabled, force_join_channel: g.force_join_channel })
  await ctx.editMessageText(val ? '⁄©Ÿæ⁄Üÿß: ÿ±Ÿàÿ¥ŸÜ ‚úÖ' : '⁄©Ÿæ⁄Üÿß: ÿÆÿßŸÖŸàÿ¥ ‚ùå')
})

bot.action('cfg:fj', async (ctx) => {
  await ctx.answerCbQuery()
  const g = await getGroup(ctx.chat.id)
  const val = g.force_join_enabled ? 0 : 1
  await setCfg({ chat_id: ctx.chat.id, rules: g.rules, welcome_enabled: g.welcome_enabled, antispam_enabled: g.antispam_enabled, captcha_enabled: g.captcha_enabled, force_join_enabled: val, force_join_channel: FORCE_JOIN || g.force_join_channel })
  await ctx.editMessageText(val ? 'ÿßÿ¨ÿ®ÿßÿ± ÿπÿ∂Ÿà€åÿ™: ÿ±Ÿàÿ¥ŸÜ ‚úÖ' : 'ÿßÿ¨ÿ®ÿßÿ± ÿπÿ∂Ÿà€åÿ™: ÿÆÿßŸÖŸàÿ¥ ‚ùå')
})

// ---------- ERROR & LAUNCH ----------
bot.catch((err, ctx) => { console.error('Bot error', err); try { ctx?.reply?.('‚ö†Ô∏è ÿÆÿ∑ÿß€å ÿØÿßÿÆŸÑ€å.') } catch {} })

// Webhook server
const app = express()

app.get('/', (req, res) => {
  res.send('ü§ñ Bot is running...')
})

// MUST be before listen
app.use(bot.webhookCallback(`/bot${BOT_TOKEN}`))

app.listen(PORT, async () => {
  console.log(`üöÄ Server running on port ${PORT}`)
  if (!WEBHOOK_URL) {
    console.error('‚ö†Ô∏è WEBHOOK_URL is missing in .env')
    return
  }
  try {
    await bot.telegram.setWebhook(`${WEBHOOK_URL}/bot${BOT_TOKEN}`)
    console.log('‚úÖ Webhook set')
  } catch (e) {
    console.error('‚ùå setWebhook failed:', e)
  }
})
